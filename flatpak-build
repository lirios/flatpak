#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is part of Liri.
#
# Copyright (C) 2018 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
#
# $BEGIN_LICENSE:GPL3+$
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# $END_LICENSE$
#

from utilities import command

import base64
import datetime
import os
import tempfile


class Builder(object):
    class Error(Exception):
        pass

    def __init__(self, repo_path=None, state_path=None, channel={}):
        self.repo_path = repo_path
        self.state_path = state_path
        self.channel = channel

    def build(self, arch=None, jobs=None, gpg_homedir=None, gpg_sign=None):
        # Install the flathub remote
        command(['flatpak', 'remote-add', 'flathub', '--from', 'https://flathub.org/repo/flathub.flatpakrepo', '--user', '--if-not-exists'])
        # Build apps
        for filename in self.channel.get('apps', []):
            app_id = os.path.basename(filename).replace('.yaml', '')
            now = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            subject = 'Build of %s at %s' % (app_id, now)
            argv = ['flatpak-builder', '--ccache', '--force-clean', '--install-deps-from=flathub',
                    '--subject=' + subject,
                    '--install', '--user']
            if self.repo_path:
                argv += ['--repo=' + self.repo_path]
            if self.state_path:
                argv += ['--state-dir=' + self.state_path]
            if arch:
                argv += ['--arch=' + arch]
            if jobs:
                argv += ['--jobs=' + str(jobs)]
            argv += ['build', filename]
            if command(argv, echo=True, output=True).returncode != 0:
                raise Builder.Error('Failed to build ' + app_id)

    def export(self, gpg_homedir=None, gpg_sign=None):
        # Export all apps
        for filename in self.channel.get('apps', []):
            argv = ['flatpak-builder', '--force-clean']
            if self.repo_path:
                argv += ['--repo=' + self.repo_path]
            if self.state_path:
                argv += ['--state-dir=' + self.state_path]
            if gpg_homedir:
                argv += ['--gpg-homedir=' + gpg_homedir]
            if gpg_sign:
                argv += ['--gpg-sign=' + gpg_sign]
            argv += ['build', filename]
            if command(argv, echo=True, output=True).returncode != 0:
                raise Builder.Error('Failed to export ' + app_id)

        # Export GPG key to a file
        gpg_filename = tempfile.mkstemp(prefix=str(os.getpid()))[1]
        if os.path.exists(gpg_filename):
            os.unlink(gpg_filename)
        if command(['gpg2', '--output', gpg_filename, '--export', gpg_sign], echo=True, output=True).returncode != 0:
            raise Builder.Error('Failed to export GPG key')
        # Export repository
        argv = ['flatpak', 'build-update-repo', self.repo_path, '--gpg-import=' + gpg_filename,
                '--gpg-sign=' + gpg_sign, '--generate-static-deltas', '--prune', '--title=Liri']
        if gpg_homedir:
            argv += ['--gpg-homedir=' + gpg_homedir]
        if command(argv, echo=True, output=True).returncode != 0:
            raise Builder.Error('Failed to export')


if __name__ == '__main__':
    import argparse
    import multiprocessing
    import yaml
    import sys

    ARCH = command(['flatpak', '--default-arch']).stdout.decode('utf-8').strip()

    parser = argparse.ArgumentParser()
    parser.add_argument('--repo', metavar='PATH', help='OSTree repository',
                        action='store', default=None)
    parser.add_argument('--state-dir', metavar='PATH', help='State directory',
                        action='store', default=None)
    parser.add_argument('--channel', metavar='PATH', help='channel file',
                        type=argparse.FileType('r'), action='store', required=True)
    parser.add_argument('--arch', help='architecture (default {})'.format(ARCH),
                        action='store', default=ARCH)
    parser.add_argument('--jobs', help='number of parallel jobs',
                        action='store', type=int, default=None)
    parser.add_argument('--export', help='export repository',
                        action='store_true')
    parser.add_argument('--gpg-homedir', help='GPG directory to use when looking for keyrings',
                        action='store', type=str)
    parser.add_argument('--gpg-sign', help='GPG key to sign commits',
                        action='store', type=str)

    args = parser.parse_args()

    if args.export is True and not (args.repo and args.gpg_sign):
        print('Export requires --repo and --gpg-sign', file=sys.stderr)
        sys.exit(1)

    channel = yaml.load(args.channel)

    builder = Builder(repo_path=args.repo, state_path=args.state_dir, channel=channel)
    builder.build(arch=args.arch, jobs=args.jobs, gpg_homedir=args.gpg_homedir, gpg_sign=args.gpg_sign)
    if args.export is True:
        builder.export(gpg_homedir=args.gpg_homedir, gpg_sign=args.gpg_sign)
